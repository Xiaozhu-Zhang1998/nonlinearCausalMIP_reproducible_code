value
# Best lambda value
best_lambda_ridge <- cv_ridge$lambda.min
cat("Best lambda for Ridge:", best_lambda_ridge, "\n")
# Predict on test set using best lambda
ridge_pred <- predict(ridge_model, s = best_lambda_ridge, newx = x_test)
ridge_mse <- mean((y_test - ridge_pred)^2)
# Best lambda value
best_lambda_ridge <- cv_ridge$lambda.min
cat("Best lambda for Ridge:", best_lambda_ridge, "\n")
# Predict on test set using best lambda
ridge_pred <- predict(ridge_model, s = best_lambda_ridge, newx = x_test)
ridge_mse <- mean((y_test - ridge_pred)^2)
cat("Test MSE for Ridge Regression:", ridge_mse, "\n")
# Examine coefficients at best lambda
ridge_coef <- predict(ridge_model, type = "coefficients", s = best_lambda_ridge)
head(ridge_coef, 10)  # Show first 10 coefficients
# Fit lasso model
lasso_model <- glmnet(x, y, alpha = 1, lambda = lambda_grid)
# Plot coefficient paths
plot(lasso_model, xvar = "lambda", label = TRUE, main = "Lasso Coefficient Paths")
# Cross-validation to find optimal lambda
set.seed(123)
cv_lasso <- cv.glmnet(x, y, alpha = 1)
plot(cv_lasso)
# Fit lasso model
lasso_model <- glmnet(x, y, alpha = 1, lambda = lambda_grid)
# Plot coefficient paths
plot(lasso_model, xvar = "lambda", label = TRUE, main = "Lasso Coefficient Paths")
# Cross-validation to find optimal lambda
set.seed(123)
cv_lasso <- cv.glmnet(x, y, alpha = 1)
plot(cv_lasso)
# Best lambda value
best_lambda_lasso <- cv_lasso$lambda.min
cat("Best lambda for Lasso:", best_lambda_lasso, "\n")
# Predict on test set using best lambda
lasso_pred <- predict(lasso_model, s = best_lambda_lasso, newx = x_test)
lasso_mse <- mean((y_test - lasso_pred)^2)
cat("Test MSE for Lasso:", lasso_mse, "\n")
# Examine coefficients at best lambda
lasso_coef <- predict(lasso_model, type = "coefficients", s = best_lambda_lasso)
cat("Test MSE for Lasso:", lasso_mse, "\n")
# Examine coefficients at best lambda
lasso_coef <- predict(lasso_model, type = "coefficients", s = best_lambda_lasso)
lasso_nonzero <- sum(lasso_coef[-1] != 0)  # Exclude intercept
cat("Number of non-zero coefficients:", lasso_nonzero, "out of", ncol(x), "\n")
cv_lasso$lambda.1se
?rpart
install.packages("rpart")
?rpart
?rpart::rpart
# Problem 6 ====
X = matrix(c(2,0,3,0,2,3), nrow = 3)
Sigma = t(X) %*% X / 3
data_points = data.frame(x1 = c(2,0,3,1,1,3), x2 = c(0,2,3,1,1,3)) %>%
mutate(Type = c(rep("Data",3), rep("Projection", 3)))
X = matrix(c(2,0,3,0,2,3), nrow = 3)
Sigma = t(X) %*% X / 2
U = eigen(Sigma)$vectors
U
eigen(Sigma)
Sigma
Sigma * 2
U
1/sqrt(2)
1/sqrt(2) == U[1,1]
Sigma = t(X) %*% X / 2
eigen(Sigma)
X
colMeans(X)
5/3
X_center = X - 5/3
X_center
X[1]
2 - 5/3
X = matrix(c(2,0,3,0,2,3), nrow = 3)
Sigma = t(X) %*% X / 2
eigen(Sigma)$values
eigen(Sigma)$vectors
# alternative sol 2
X = matrix(c(2,0,3,0,2,3), nrow = 3)
X_center = X - 5/3
Sigma = t(X_center) %*% X_center / 3
eigen(Sigma)$values
eigen(Sigma)$vectors
Sigma
16/9
0.7071068
sqrt(2) / 2
# alternative sol 3
X = matrix(c(2,0,3,0,2,3), nrow = 3)
X_center = X - 5/3
Sigma = t(X_center) %*% X_center / 2
Sigma
7/3
eigen(Sigma)$values
eigen(Sigma)$vectors
# alternative sol 2
X = matrix(c(2,0,3,0,2,3), nrow = 3)
X_center = X - 5/3
Sigma = t(X_center) %*% X_center / 3
eigen(Sigma)$values
eigen(Sigma)$vectors
X_center %*% eigen(Sigma)$vectors[,1]
2 * sqrt(2) / 3
4 * sqrt(2) / 3
1:M
M = 10
1:M
1:M - 1
(1:M-1)
RS
RS
?write.csv
?v
?data.frame
EqVarDAG
setwd("~/Desktop/MIPS_code/EqVarDAG")
source("DAG_from_Ordering.R")
source("EqVarDAG_BU.R")
source("EqVarDAG_HD_CLIME.R")
source("EqVarDAG_HD_TD.R")
source("EqVarDAG_TD.R")
source("randGGM.R")
source("vselect.R")
data_name = "cloud"
edges_file <- read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, ".txt", collapse = ""), header = FALSE)
vec_list <- apply(edges_file, 1, function(row) c(row[1], row[2]))
edges_star <- lapply(1:nrow(edges_file), function(i) c(edges_file[i, 1], edges_file[i, 2]))
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "/W_", m, ".csv"), header = FALSE))
W_train = W[1:500,]
W_model = W[501:1000,]
m
m = 1
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "/W_", m, ".csv"), header = FALSE))
data_name
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "_diffvar/W_", m, ".csv"), header = FALSE))
W_train = W[1:500,]
W_model = W[501:1000,]
W_val = W[1001:1500,]
EqVarDAG_TD_obj = EqVarDAG::EqVarDAG_TD(W_train, mtd = "cvlasso")
EqVarDAG_TD_obj
EqVarDAG_TD_obj$adj
?EqVarDAG::EqVarDAG_TD
EqVarDAG_TD
EqVarDAG_TD(W_train, mtd = "cvlasso")
source("DAG_from_Ordering.R")
source("EqVarDAG_BU.R")
source("EqVarDAG_HD_CLIME.R")
source("EqVarDAG_HD_TD.R")
source("EqVarDAG_TD.R")
source("randGGM.R")
source("vselect.R")
EqVarDAG_TD(W_train, mtd = "cvlasso")
data_name = "cloud"
edges_file <- read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, ".txt", collapse = ""), header = FALSE)
vec_list <- apply(edges_file, 1, function(row) c(row[1], row[2]))
edges_star <- lapply(1:nrow(edges_file), function(i) c(edges_file[i, 1], edges_file[i, 2]))
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "_diffvar/W_", m, ".csv"), header = FALSE))
m = 1
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "_diffvar/W_", m, ".csv"), header = FALSE))
W_train = W[1:500,]
W_model = W[501:1000,]
W_val = W[1001:1500,]
EqVarDAG_TD(W_train, mtd = "cvlasso")
source("DAG_from_Ordering.R")
source("EqVarDAG_BU.R")
source("EqVarDAG_HD_CLIME.R")
source("EqVarDAG_HD_TD.R")
source("EqVarDAG_TD.R")
source("randGGM.R")
source("vselect.R")
EqVarDAG_TD(W_train, mtd = "cvlasso")
Cutoff
Cutoff = exp(seq(from = log(0.1), to = log(0.00001), length.out = 20))
EqVarDAG_TD_obj = EqVarDAG_TD(W_train, mtd = "cvlasso", alpha = cutoff)
for (cutoff in Cutoff) {
EqVarDAG_TD_obj = EqVarDAG_TD(W_train, mtd = "cvlasso", alpha = cutoff)
Loss_val = c(Loss_val, loss_from_adj(EqVarDAG_TD_obj$adj, W_model, W_val) )
}
## eqvarDAG_TD ====
Loss_val = c()
for (cutoff in Cutoff) {
EqVarDAG_TD_obj = EqVarDAG_TD(W_train, mtd = "cvlasso", alpha = cutoff)
Loss_val = c(Loss_val, loss_from_adj(EqVarDAG_TD_obj$adj, W_model, W_val) )
}
# functions ====
loss_from_adj = function(Adj, W_model, W_val) {
n = nrow(W_val)
p = ncol(W_val)
var_hat = c()
for(i in 1:p){
idx = which(Adj[,i] !=0)
if(length(idx) != 0) {
y_model = W_model[,i]
X_model = W_model[,idx]
y_val = W_val[,i]
X_val = W_val[,idx]
r = y_val - X_val %*% solve(t(X_model) %*% X_model) %*% t(X_model) %*% y_model
} else {
r = W_val[, i]
}
var_hat = c(var_hat, norm(r, "2")^2 / n )
}
# find loss value
loss_val = sum(log(var_hat)) + p
return(loss_val)
}
edge2adj = function(edges, p) {
adj = matrix(0, p, p)
for(i in 1:length(edges)) {
adj[edges[[i]][1], edges[[i]][2]] = 1
}
return(adj)
}
adj2edge = function(adj, p) {
edges = list()
for(i in 1:p) {
for(j in 1:p) {
if (adj[i,j] == 1) {
edges = c(edges, list(c(i,j)))
}
}
}
return(edges)
}
edge_diff_npvar = function(edges_star, adj_hat, p) {
sum( abs( edge2adj(edges_star, p) - adj_hat ) )
}
## eqvarDAG_TD ====
Loss_val = c()
for (cutoff in Cutoff) {
EqVarDAG_TD_obj = EqVarDAG_TD(W_train, mtd = "cvlasso", alpha = cutoff)
Loss_val = c(Loss_val, loss_from_adj(EqVarDAG_TD_obj$adj, W_model, W_val) )
}
idx = which.min(Loss_val)
cutoff = Cutoff[idx]
cutoff
t1 = Sys.time()
EqVarDAG_TD_obj = EqVarDAG::EqVarDAG_TD(W_train, mtd = "cvlasso", alpha = cutoff)
t2 = Sys.time()
t1 = Sys.time()
EqVarDAG_TD_obj = EqVarDAG_TD(W_train, mtd = "cvlasso", alpha = cutoff)
t2 = Sys.time()
edge_diff_npvar(edges_star, EqVarDAG_TD_obj$adj, p)
p = ncol(W_train)
edge_diff_npvar(edges_star, EqVarDAG_TD_obj$adj, p)
EqVarDAG_BU_obj = EqVarDAG_BU(W_train, mtd = "cvlasso", alpha = cutoff)
Loss_val = c(Loss_val, loss_from_adj(EqVarDAG_BU_obj$adj, W_model, W_val) )
## eqvarDAG_BU ====
Loss_val = c()
for (cutoff in Cutoff) {
EqVarDAG_BU_obj = EqVarDAG_BU(W_train, mtd = "cvlasso", alpha = cutoff)
Loss_val = c(Loss_val, loss_from_adj(EqVarDAG_BU_obj$adj, W_model, W_val) )
}
idx = which.min(Loss_val)
cutoff = Cutoff[idx]
t1 = Sys.time()
EqVarDAG_BU_obj = EqVarDAG_TD(W_train, mtd = "cvlasso", alpha = cutoff)
t2 = Sys.time()
edge_diff_npvar(edges_star, EqVarDAG_BU_obj$adj, p)
source("ICML.R")
setwd("~/Desktop/MIPS_code/RESIT")
source("ICML.R")
ICML(W_train)
source("fitting.R")
ICML(W_train)
source("fitting.R")
source("ICML.R")
source("indtestAll.R")
source("indtestHsic.R")
source("indtestNutualHsic.R")
setwd("~/Desktop/MIPS_code/RESIT")
source("fitting.R")
source("ICML.R")
source("indtestAll.R")
source("indtestHsic.R")
source("indtestNutualHsic.R")
source("fitting.R")
source("ICML.R")
source("indtestAll.R")
source("indtestHsic.R")
source("indtestMutualHsic.R")
ICML(W_train)
est = ICML(W_train, model = train_gam)
est
edge_diff_npvar(edges_star, est, p)
Cutoff
data_name
## RESIT ====
Loss_val = c()
Cutoff = exp(seq(from = log(0.1), to = log(0.00001), length.out = 10))
Cutoff
cutoff
cat("cutoff:", cutoff)
## RESIT ====
Loss_val = c()
for (cutoff in Cutoff) {
RESIT_obj = ICML(W_train, mtd = "cvlasso", alpha = cutoff, model = train_gam)
Loss_val = c(Loss_val, loss_from_adj(RESIT_obj, W_model, W_val) )
cat("cutoff:", cutoff)
}
## RESIT ====
Loss_val = c()
for (cutoff in Cutoff) {
RESIT_obj = ICML(W_train, alpha = cutoff, model = train_gam)
Loss_val = c(Loss_val, loss_from_adj(RESIT_obj, W_model, W_val) )
cat("cutoff:", cutoff)
}
idx = which.min(Loss_val)
cutoff = Cutoff[idx]
cutoff
t1 = Sys.time()
RESIT_obj = ICML(W_train, mtd = "cvlasso", alpha = cutoff, model = train_gam)
t1 = Sys.time()
RESIT_obj = ICML(W_train, alpha = cutoff, model = train_gam)
t2 = Sys.time()
c(
m, p, "RESIT",
edge_diff_npvar(edges_star, RESIT_obj, p),
t2 - t1
)
t1
t2
t1 = Sys.time()
RESIT_obj = ICML(W_train, alpha = cutoff, model = train_gam)
t2 = Sys.time()
c(
m, p, "RESIT",
edge_diff_npvar(edges_star, RESIT_obj, p),
difftime(t2, t1, units = "secs")
)
data_name = "cloud"
edges_file <- read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, ".txt", collapse = ""), header = FALSE)
vec_list <- apply(edges_file, 1, function(row) c(row[1], row[2]))
edges_star <- lapply(1:nrow(edges_file), function(i) c(edges_file[i, 1], edges_file[i, 2]))
RS = matrix(0, nrow = 0, ncol = 5)
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "_equalvar/W_", m, ".csv"), header = FALSE))
W_train = W[1:500,]
W_model = W[501:1000,]
W_val = W[1001:1500,]
p = ncol(W)
## RESIT ====
Loss_val = c()
for (cutoff in Cutoff) {
RESIT_obj = ICML(W_train, alpha = cutoff, model = train_gam)
Loss_val = c(Loss_val, loss_from_adj(RESIT_obj, W_model, W_val) )
cat("cutoff:", cutoff, "\n")
}
idx = which.min(Loss_val)
cutoff = Cutoff[idx]
t1 = Sys.time()
RESIT_obj = ICML(W_train, alpha = cutoff, model = train_gam)
t2 = Sys.time()
c(
m, p, "RESIT",
edge_diff_npvar(edges_star, RESIT_obj, p),
difftime(t2, t1, units = "secs")
)
cat("cutoff:", cutoff, "\n")
cat("cutoff:", cutoff, difftime(t2, t1, units = "secs"), "\n")
data_name = "funnel"
edges_file <- read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, ".txt", collapse = ""), header = FALSE)
vec_list <- apply(edges_file, 1, function(row) c(row[1], row[2]))
edges_star <- lapply(1:nrow(edges_file), function(i) c(edges_file[i, 1], edges_file[i, 2]))
RS = matrix(0, nrow = 0, ncol = 5)
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "_diffvar/W_", m, ".csv"), header = FALSE))
W_train = W[1:500,]
W_model = W[501:1000,]
W_val = W[1001:1500,]
p = ncol(W)
## RESIT ====
Loss_val = c()
for (cutoff in Cutoff) {
t1 = Sys.time()
RESIT_obj = ICML(W_train, alpha = cutoff, model = train_gam)
t2 = Sys.time()
Loss_val = c(Loss_val, loss_from_adj(RESIT_obj, W_model, W_val) )
cat("cutoff:", cutoff, difftime(t2, t1, units = "secs"), "\n")
}
1410 / 60
## NPVAR ====
eta = 0.00001
while(TRUE) {
result1 = NPVAR(x = W_train, layer.select = TRUE, eta = eta)
if (length(result1$layers) == p) {
break
} else {
eta = eta / 2
}
}
layers = unlist(result1$layers) - 1
W = as.matrix(read.csv(paste0("~/Desktop/MIPS_code/dataset/", data_name, "_diffvar/W_", m, ".csv"), header = FALSE))
W_train = W[1:500,]
W_model = W[501:1000,]
W_val = W[1001:1500,]
p = ncol(W)
## NPVAR ====
eta = 0.00001
while(TRUE) {
result1 = NPVAR(x = W_train, layer.select = TRUE, eta = eta)
if (length(result1$layers) == p) {
break
} else {
eta = eta / 2
}
}
setwd("~/Desktop/MIPS_code/NPVAR/")
source('NPVAR.R')
source('utils.R')
data_name = "funnel"
## NPVAR ====
eta = 0.00001
while(TRUE) {
result1 = NPVAR(x = W_train, layer.select = TRUE, eta = eta)
if (length(result1$layers) == p) {
break
} else {
eta = eta / 2
}
}
layers = unlist(result1$layers) - 1
len = length(layers)
win = floor(len * 0.2)
Cutoff = exp(seq(from = log(0.1), to = log(0.0001), length.out = 10))
Loss_val = c()
for (cutoff in Cutoff) {
est = prune(W_train, result1$ancestors, cutoff = cutoff)
Loss_val = c(Loss_val, loss_from_adj(est, W_model, W_val) )
}
idx = which.min(Loss_val)
cutoff = Cutoff[idx]
t1 = Sys.time()
result1 = NPVAR(x = W_train, layer.select = TRUE, eta = eta)
est = prune(W_train, result1$ancestors, cutoff = cutoff)
t2 = Sys.time()
Cutoff
cutoff = 0.1
est = prune(W_train, result1$ancestors, cutoff = cutoff)
sum(est)
cutoff = Cutoff[2]
est = prune(W_train, result1$ancestors, cutoff = cutoff)
sum(est)
cutoff = Cutoff[3]
cutoff = Cutoff[4]
cutoff = Cutoff[3]
est = prune(W_train, result1$ancestors, cutoff = cutoff)
sum(est)
cutoff = Cutoff[4]
est = prune(W_train, result1$ancestors, cutoff = cutoff)
sum(est)
adj2edge = function(adj, p) {
edges = list()
for(i in 1:p) {
for(j in 1:p) {
if (adj[i,j] == 1) {
edges = c(edges, list(c(i,j)))
}
}
}
return(edges)
}
adj2edge(est, p)
superset = list()
adj2edge(est, p)
union(superset, adj2edge(est, p))
superset = union(superset, adj2edge(est, p))
superset = union(superset, adj2edge(est, p))
superset
superset = union(superset, adj2edge(est, p))
superset
superset = union(superset, list(c(15,18), c(11,12)))
supserset
superse
superset
superset
data.frame(superset)
superset
test = data.frame()
test
est
superset
superset[[i]]
i = 1
superset[[i]]
sort(superset[[i]])
sort(superset[[i]])
superset
superset_df = data.frame()
for(i in 1:length(superset)) {
superset_df = rbind(sort(superset[[i]]))
}
superset_df
superset_df = data.frame()
for(i in 1:length(superset)) {
superset_df = rbind(superset_df, sort(superset[[i]]))
}
superset_df
dplyr::distinct(superset_df)
?write.csv
write.csv("test.csv", row.names = FALSE, col.names = FALSE)
write.csv(superset_df, "test.csv", row.names = FALSE, col.names = FALSE)
?write.table
write.table(superset_df, "test.txt", row.names = FALSE, col.names = FALSE, sep = ",")
superset_df = dplyr::distinct(superset_df)
write.table(superset_df, "test.txt", row.names = FALSE, col.names = FALSE, sep = ",")
superset_df
arrange(superset_df, "X1L")
dplyr::arrange(superset_df, "X1L")
560 / 60
superset_df
